#!/usr/bin/env python3

# check for the venv
from lib import sanity_check

sanity_check.check_venv(__file__)

import argparse
import json
import logging
import os
import re
import subprocess
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
from typing import Dict, Iterable, List

from zulint import lister

from lib.html_branches import build_id_dict
from lib.template_parser import validate
from scripts.lib.zulip_tools import ENDC, FAIL, WARNING
from tools.lib.capitalization import check_capitalization

DJANGO_PO_REGEX = re.compile('msgid "(.*?)"')

EXCLUDED_FILES = [
    ## Test data Files for testing modules in tests
    "tools/tests/test_template_data",
    # Our parser doesn't handle the way its conditionals are layered
    'templates/zerver/emails/missed_message.source.html',
    # Previously unchecked and our parser doesn't like its indentation
    'static/assets/icons/template.hbs',
]

def check_files(modified_only: bool, no_generate: bool, targets: List[str]) -> None:
    by_lang = lister.list_files(
        targets=targets,
        modified_only=args.modified,
        ftypes=['hbs', 'html'],
        group_by_ftype=True, exclude=EXCLUDED_FILES,
    )

    check_handlebar(by_lang['hbs'])
    check_html(by_lang['html'], no_generate)
    check_python(by_lang['py'])

def check_html(templates: Iterable[str], no_generate: bool) -> None:
    # Our files with .html extensions are usually for Django, but we also
    # have a few static .html files.
    logging.basicConfig(format='%(levelname)s:%(message)s')
    templates = sorted(fn for fn in templates)
    # Use of lodash templates <%= %>.
    if 'templates/zerver/team.html' in templates:
        templates.remove('templates/zerver/team.html')

    def check_for_duplicate_ids(templates: List[str]) -> Dict[str, List[str]]:
        template_id_dict = build_id_dict(templates)
        # TODO: Clean up these cases of duplicate ids in the code
        IGNORE_IDS = [
            'api-example-tabs',
            'errors',
            'error-message-box',
            'email',
            'messages',
            'registration',
            'pw_strength',
            'id_password',
            'top_navbar',
            'id_email',
            'id_terms',
            'send_confirm',
            'register',
            'footer',
            'charged_amount',
            'change-plan-status',
            # Temporary while we have searchbox forked
            'search_exit',
            'search_query',
            'message_view_header',
            'search_arrows',
            'searchbox_form',
            'searchbox',
        ]
        bad_ids_dict = {ids: fns for ids, fns in template_id_dict.items()
                        if (ids not in IGNORE_IDS) and len(fns) > 1}

        if no_generate:
            ignorable_ids_dict = {ids: fns for ids, fns in template_id_dict.items()
                                  if ids in IGNORE_IDS and len(fns) > 1}

            for ids, fns in ignorable_ids_dict.items():
                logging.warning("Duplicate ID(s) detected :Id '" + ids +
                                "' present at following files:")
                for fn in fns:
                    print(fn)

        for ids, fns in bad_ids_dict.items():
            logging.error("Duplicate ID(s) detected :Id '" + ids +
                          "' present at following files:")
            for fn in fns:
                print(fn)
        return bad_ids_dict

    bad_ids_list: List[str] = []
    archive_templates = [fn for fn in templates if 'templates/zerver/archive' in fn]
    templates = [fn for fn in templates if 'templates/zerver/archive' not in fn]

    bad_ids_list += list(check_for_duplicate_ids(archive_templates).keys())
    bad_ids_list += list(check_for_duplicate_ids(templates).keys())

    if bad_ids_list:
        print('Exiting--please clean up all duplicates before running this again.')
        sys.exit(1)

    for fn in templates:
        # Many of our Django templates have strange indentation.  The
        # indentation errors are often harmless, even stylistically
        # harmless, but they tend to be in files that might be old
        # and might eventually require more scrutiny for things like
        # localization.  See GitHub #1236.
        bad_files = [
            # These use various whitespace-dependent formatting that
            # prevent cleaning them.
            'templates/corporate/zephyr-mirror.html',
            # Can't clean this because of `preserve_spaces`
            'templates/zerver/app/markdown_help.html',
        ]
        validate(fn=fn, check_indent=(fn not in bad_files))

    # Ignore these files since these have not been cleaned yet :/
    IGNORE_FILES = [
        # zephyr-mirror.html has some whitespace-dependent formatting
        # for code blocks that prevent cleaning it.  Might make sense
        # to convert it to a /help/ Markdown article.
        'templates/corporate/zephyr-mirror.html',
        # Can't clean this because of `preserve_spaces`
        'templates/zerver/app/markdown_help.html',
    ]
    # TODO: Clean these files
    for fn in templates:
        if fn not in IGNORE_FILES:
            if not validate_html(fn):
                sys.exit(1)

def check_handlebar(templates: Iterable[str]) -> None:
    # Check all our handlebars templates.
    templates = [fn for fn in templates if fn.endswith('.hbs')]

    IGNORE_FILES = [
        # TODO: Add some exclude mechanism for the line-wrapping issue here.
        'static/templates/recipient_row.hbs',
    ]

    for fn in templates:
        if fn in IGNORE_FILES:
            continue
        validate(fn=fn, check_indent=True)

    for fn in templates:
        if fn in IGNORE_FILES:
            continue
        if not validate_html(fn):
            sys.exit(1)

def check_python(templates: Iterable[str]) -> None:
    # Check all our python files.
    templates = [fn for fn in templates if fn.endswith('.py')]

    IGNORE_FILES = [
        # TODO: Add some exclude mechanism for the line-wrapping issue here.
        
    ]

    for fn in templates:
        if fn in IGNORE_FILES:
            continue
        validate(fn=fn, check_indent=True)

    for fn in templates:
        if fn in IGNORE_FILES:
            continue
        if not validate_html(fn):
            sys.exit(1)

def validate_html(fn: str) -> int:
    with open(fn) as f:
        html = f.read()
        if not args.no_generate:
            subprocess.call(['./manage.py', 'makemessages', '--locale', 'en'],
                        stderr=subprocess.STDOUT)

    with open('locale/en/translations.json') as f:
        data = json.load(f)
        frontend = check_capitalization(list(data.keys()))
        frontend_errors, frontend_ignored, banned_errors_front = frontend

    with open('locale/en/LC_MESSAGES/django.po') as f:
        rows = [r for r in DJANGO_PO_REGEX.findall(f.read()) if r]
        backend = check_capitalization(rows)
        backend_errors, backend_ignored, banned_errors_back = backend

    if frontend_errors:
        print(WARNING + 'Strings not properly capitalized in frontend file:'
            f'{fn}'  +ENDC)
        print('\n'.join(frontend_errors))

    if backend_errors:
        print(WARNING + 'Strings not properly capitalized in backend file:'
            f'{fn}'+ ENDC)
        print('\n'.join(backend_errors))

    if banned_errors_front:
        print(WARNING + "Found banned words in frontend strings" + ENDC)
        print('\n'.join(banned_errors_front))

    if banned_errors_back:
        print(WARNING + "Found banned words in backend strings" + ENDC)
        print('\n'.join(banned_errors_back))

    if args.show_ignored:
        print(WARNING + "Strings which were ignored: " + ENDC)
        print('\n'.join(frontend_ignored + backend_ignored))

    if frontend_errors or backend_errors or banned_errors_back or banned_errors_front:
        # Point the user to the documentation on what the policy is.
        docs_url = "https://zulip.readthedocs.io/en/latest/translating/translating.html#capitalization"
        print(WARNING + "See " + docs_url + ENDC)
        print(FAIL + "Failed!" + ENDC)
        sys.exit(1)
    else:
        sys.exit(0)

    return 0

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-m', '--modified',
                        action='store_true',
                        help='only check modified files')
    parser.add_argument('--show-ignored',
                        action='store_true',
                        help='Show strings that passed the check because they '
                             'contained ignored phrases.')
    parser.add_argument('--no-generate',
                        action='store_true',
                        help="Don't run makemessages command.")
    parser.add_argument('targets', nargs=argparse.REMAINDER)
    args = parser.parse_args()
    print(args.no_generate)
    check_files(args.modified, args.no_generate, args.targets)

